<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <title>Metoda mersului invers - cu tastatură</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1300px; margin: 20px auto; }

    label { display: block; margin-top: 10px; font-weight: bold; }
    textarea {
      width: 100%;
      min-height: 60px;
      padding: 6px;
      margin-top: 4px;
      box-sizing: border-box;
      font-size: 1.1rem;
    }
    input[type="text"] {
      width: 100%;
      padding: 6px;
      margin-top: 4px;
      font-size: 1.1rem;
      box-sizing: border-box;
    }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 2%;
      margin-top: 15px;
    }
    .col {
      width: 32%;
    }
    button {
      margin: 6px 3px;
      padding: 6px 12px;
      cursor: pointer;
    }
    .pas {
      margin: 10px 0;
      padding: 10px;
      border-left: 4px solid #0077cc;
      background: #f4f9ff;
      font-size: 1.15rem;
      line-height: 1.5rem;
    }
    .pas strong {
      display: block;
      font-size: 1.1rem;
      margin-bottom: 4px;
    }
    hr { margin-top: 20px; }

    /* layout principal: stânga conținut, dreapta tastatura */
    .main-row {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      margin-top: 10px;
    }
    .left-pane {
      flex: 1;
      min-width: 0;
    }
    .right-pane {
      width: 280px;
    }

    /* tastatura în stil grilă */
    #keyboard {
      padding: 10px;
      border: 1px solid #ccc;
      background: #fbf6ee;
      border-radius: 6px;
    }
    #keyboard h3 {
      margin-top: 0;
      margin-bottom: 6px;
      font-size: 1rem;
      text-align: center;
    }
    .kb-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }
    .kb-btn {
      border: 1px solid #e0d7c7;
      background: #fdf7ef;
      padding: 10px 4px;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
    }
    .kb-btn:hover {
      background: #f3ebdd;
    }
    .kb-wide {
      font-size: 0.9rem;
    }
    .kb-equal {
      background: #0066cc;
      color: #fff;
      font-weight: bold;
    }
    .kb-equal:hover {
      background: #0053a6;
    }
  </style>
</head>
<body>

<h2>Metoda mersului invers</h2>

<div class="main-row">
  <!-- STÂNGA: relație, pași, câmpuri -->
  <div class="left-pane">
    <p><strong>1. Introdu relația din problemă:</strong></p>

    <input id="relInitiala" type="text"
           value="[(x:4+5):6+10]:10+3=13"
           onfocus="setActive('relInitiala')">

    <button onclick="porneste()">Pornește de la această relație</button>

    <hr>

    <p><strong>2.  Rezolvă problema : </strong><br>
    – În caseta liberă notează <strong>operația inversă</strong> ultimului pas din problemă.<br>
    – Modifică partea stângă și partea dreaptă a relației, astfel încât să obții pasul următor.<br>
    Apoi apasă <strong>„Înregistrează pasul”</strong>.</p>

    <div class="row">
      <div class="col">
        <label>Partea stângă:</label>
        <textarea id="stanga" onfocus="setActive('stanga')"></textarea>
      </div>

      <div class="col">
        <label>Partea dreaptă:</label>
        <textarea id="dreapta" onfocus="setActive('dreapta')"></textarea>
      </div>

      <div class="col">
        <label>Operația inversă:</label>
        <textarea id="explicatie" onfocus="setActive('explicatie')"></textarea>
      </div>
    </div>

    <button onclick="salveazaPas()">Înregistrează pasul</button>
    <button onclick="resetLaInitiala()">Resetare</button>

    <hr>

    <p><strong>Pașii realizați:</strong></p>
    <div id="istoric"></div>
  </div>

  <!-- DREAPTA: tastatura -->
  <div class="right-pane">
    <div id="keyboard">
      <h3>Tastatură</h3>
      <div class="kb-grid">

        <!-- rând 1 -->
        <button type="button" class="kb-btn" onclick="insertPair('(',')')">( )</button>
        <button type="button" class="kb-btn" onclick="insertPair('[',']')">[ ]</button>
        <button type="button" class="kb-btn" onclick="insertPair('{','}')">{ }</button>
        <button type="button" class="kb-btn" onclick="insertChar(':')">:</button>

        <!-- rând 2 -->
        <button type="button" class="kb-btn" onclick="insertChar('7')">7</button>
        <button type="button" class="kb-btn" onclick="insertChar('8')">8</button>
        <button type="button" class="kb-btn" onclick="insertChar('9')">9</button>
        <button type="button" class="kb-btn" onclick="insertChar('×')">•</button>

        <!-- rând 3 -->
        <button type="button" class="kb-btn" onclick="insertChar('4')">4</button>
        <button type="button" class="kb-btn" onclick="insertChar('5')">5</button>
        <button type="button" class="kb-btn" onclick="insertChar('6')">6</button>
        <button type="button" class="kb-btn" onclick="insertChar('-')">−</button>

        <!-- rând 4 -->
        <button type="button" class="kb-btn" onclick="insertChar('1')">1</button>
        <button type="button" class="kb-btn" onclick="insertChar('2')">2</button>
        <button type="button" class="kb-btn" onclick="insertChar('3')">3</button>
        <button type="button" class="kb-btn" onclick="insertChar('+')">+</button>

        <!-- rând 5 -->
        <button type="button" class="kb-btn kb-wide" onclick="insertChar('x')">x</button>
        <button type="button" class="kb-btn" onclick="insertChar('0')">0</button>
        <button type="button" class="kb-btn kb-wide" onclick="backspace()">șterge</button>
        <button type="button" class="kb-btn kb-equal" onclick="insertChar('=')">=</button>

      </div>
    </div>
  </div>
</div>

<script>
  // ================= UTILITĂȚI PENTRU VERIFICARE =================

  // verifică dacă parantezele () [] {} sunt echilibrate
  function parantezeEchilibrate(s) {
    const stack = [];
    const pairs = {')': '(', ']': '[', '}': '{'};
    for (const ch of s) {
      if (ch === '(' || ch === '[' || ch === '{') {
        stack.push(ch);
      } else if (ch === ')' || ch === ']' || ch === '}') {
        if (!stack.length || stack[stack.length - 1] !== pairs[ch]) return false;
        stack.pop();
      }
    }
    return stack.length === 0;
  }

  // normalizează expresia pentru comparație (fără spații, fără paranteze exterioare inutile)
  function normalizeExpr(str) {
    let s = str.replace(/\s+/g, '');
    // eliminăm paranteze exterioare care cuprind TOT șirul, dacă sunt corect închise
    let changed = true;
    const pairs = [
      ['(', ')'],
      ['[', ']'],
      ['{', '}']
    ];
    while (changed && s.length >= 2) {
      changed = false;
      for (const [o, c] of pairs) {
        if (s[0] === o && s[s.length - 1] === c) {
          let depth = 0;
          let ok = true;
          for (let i = 0; i < s.length; i++) {
            const ch = s[i];
            if (ch === o) depth++;
            else if (ch === c) {
              depth--;
              if (depth === 0 && i < s.length - 1) {
                ok = false;
                break;
              }
            }
          }
          if (ok && depth === 0) {
            s = s.slice(1, -1);
            changed = true;
          }
        }
      }
    }
    return s;
  }

  // identifică ultima operație (+, -, :, ×) la nivel de suprafață în partea stângă
  // întoarce { op, base, tail } sau null
  function getLastOperation(expr) {
    const s = expr.trim();
    let depthP = 0, depthB = 0, depthC = 0;
    for (let i = s.length - 1; i >= 0; i--) {
      const ch = s[i];
      if (ch === ')') depthP++;
      else if (ch === '(') depthP--;
      else if (ch === ']') depthB++;
      else if (ch === '[') depthB--;
      else if (ch === '}') depthC++;
      else if (ch === '{') depthC--;
      else if (depthP === 0 && depthB === 0 && depthC === 0 &&
              (ch === '+' || ch === '-' || ch === ':' || ch === '×')) {
        const base = s.slice(0, i).trim();
        const tail = s.slice(i + 1).trim();
        if (!base || !tail) return null;
        return { op: ch, base, tail };
      }
    }
    return null;
  }

  // evaluează o expresie NUMERICĂ (fără x), cu +, -, :, ×, paranteze
  function evalNumeric(expr) {
    if (/[a-zA-Z]/.test(expr)) {
      throw new Error("Expresia conține litere.");
    }
    let s = expr.replace(/\s+/g, '');
    s = s.replace(/×/g, '*').replace(/•/g, '*').replace(/:/g, '/');
    s = s.replace(/\[/g, '(').replace(/\]/g, ')')
         .replace(/\{/g, '(').replace(/\}/g, ')');

    if (!s) throw new Error("Expresie goală.");

    // permitem doar cifre, + - * / . și paranteze
    if (!/^[0-9+\-*/().]+$/.test(s)) {
      throw new Error("Caractere nepermise în expresie.");
    }

    // folosim Function în loc de eval
    return Function('"use strict";return (' + s + ')')();
  }

  // verifică relația inițială
  function verificaRelInitiala(left, right) {
    if (!left || !right) {
      return { ok: false, msg: "Scrie o relație de forma expresie_cu_x = număr." };
    }
    if (!left.includes('x')) {
      return { ok: false, msg: "Partea stângă trebuie să conțină necunoscuta x." };
    }
    if (/[a-zA-Z]/.test(right)) {
      return { ok: false, msg: "Partea dreaptă trebuie să fie doar numerică (fără litere)." };
    }
    if (!parantezeEchilibrate(left) || !parantezeEchilibrate(right)) {
      return { ok: false, msg: "Parantezele nu sunt închise corect." };
    }
    const info = getLastOperation(left);
    if (!info) {
      return {
        ok: false,
        msg: "Nu pot identifica ultima operație din partea stângă.\nAsigură-te că există o operație (+, −, :, ×) la nivel de suprafață."
      };
    }
    try {
      evalNumeric(right);
    } catch (e) {
      return {
        ok: false,
        msg: "Partea dreaptă trebuie să fie un număr sau o expresie numerică validă."
      };
    }
    return { ok: true };
  }

  // verifică dacă pasul nou este corect față de pasul anterior
  function verificaPas(oldLeft, oldRight, newLeft, newRight) {
    if (!newLeft || !newRight) {
      return { ok: false, msg: "Completează atât partea stângă, cât și partea dreaptă." };
    }

    if (!parantezeEchilibrate(newLeft) || !parantezeEchilibrate(newRight)) {
      return { ok: false, msg: "Parantezele din noul pas nu sunt închise corect." };
    }

    const normOldLeft = normalizeExpr(oldLeft);
    if (normOldLeft === 'x') {
      return {
        ok: false,
        msg: "Ai ajuns deja la x.\nNu mai avem ce operație inversă să aplicăm."
      };
    }

    if (!newLeft.includes('x')) {
      return { ok: false, msg: "În partea stângă trebuie să apară necunoscuta x." };
    }
    if (/[a-zA-Z]/.test(newRight)) {
      return { ok: false, msg: "În partea dreaptă nu trebuie să apară litere, doar numere și operații." };
    }

    const info = getLastOperation(oldLeft);
    if (!info) {
      return {
        ok: false,
        msg: "Nu pot identifica ultima operație din pasul precedent."
      };
    }

    // verificăm partea stângă: trebuie să fie exact baza, după ce „ștergem” ultima operație
    const normBase = normalizeExpr(info.base);
    const normNewLeft = normalizeExpr(newLeft);
    if (normBase !== normNewLeft) {
      return {
        ok: false,
        msg: "Partea stângă nu este obținută corect.\nTrebuie să „anulezi” ultima operație din pasul precedent."
      };
    }

    // construim expresia numerică așteptată pe dreapta, aplicând operația inversă
    const tail = info.tail;
    let expectedRightExpr;
    switch (info.op) {
      case '+': // invers: - tail
        expectedRightExpr = "(" + oldRight + ")-(" + tail + ")";
        break;
      case '-': // invers: + tail
        expectedRightExpr = "(" + oldRight + ")+(" + tail + ")";
        break;
      case ':': // împărțire – invers: × tail
        expectedRightExpr = "(" + oldRight + ")×(" + tail + ")";
        break;
      case '×': // înmulțire – invers: : tail
        expectedRightExpr = "(" + oldRight + "):(" + tail + ")";
        break;
      default:
        return { ok: false, msg: "Operație necunoscută: " + info.op };
    }

    let vAsteptat, vElev;
    try {
      vAsteptat = evalNumeric(expectedRightExpr);
    } catch (e) {
      return {
        ok: false,
        msg: "Nu pot interpreta partea dreaptă a pasului precedent.\nVerifică dacă este o expresie numerică validă."
      };
    }
    try {
      vElev = evalNumeric(newRight);
    } catch (e) {
      return {
        ok: false,
        msg: "Partea dreaptă nouă nu este o expresie numerică validă."
      };
    }

    if (Math.abs(vAsteptat - vElev) > 1e-9) {
      return {
        ok: false,
        msg: "Partea dreaptă nu corespunde operației inverse.\nAr fi trebuit să obții ceva echivalent cu: " + expectedRightExpr
      };
    }

    return { ok: true };
  }

  // ================== GESTIONARE PAȘI ====================

  // fiecare pas: { left, right, expl }
  let pasi = [];
  let indexCurent = 0;
  let stangaInitiala = "";
  let dreaptaInitiala = "";

  function spargeRelatia(text) {
    const idx = text.indexOf("=");
    if (idx === -1) return { left: text, right: "" };
    return {
      left: text.slice(0, idx).trim(),
      right: text.slice(idx + 1).trim()
    };
  }

  function afiseazaPasi() {
    const container = document.getElementById("istoric");
    container.innerHTML = "";
    pasi.forEach((pas, i) => {
      const div = document.createElement("div");
      div.className = "pas";
      const titlu = document.createElement("strong");
      titlu.textContent = "Pasul " + i + ":";
      const eq = document.createElement("div");
      let textEq = pas.left + " = " + pas.right;
      if (pas.expl && pas.expl.trim() !== "") {
        textEq += " | " + pas.expl;
      }
      eq.textContent = textEq;
      div.appendChild(titlu);
      div.appendChild(eq);
      container.appendChild(div);
    });
  }

  function porneste() {
    const rel = document.getElementById("relInitiala").value;
    const parts = spargeRelatia(rel);

    const check = verificaRelInitiala(parts.left, parts.right);
    if (!check.ok) {
      alert(check.msg);
      return;
    }

    stangaInitiala = parts.left;
    dreaptaInitiala = parts.right;

    pasi = [{
      left: stangaInitiala,
      right: dreaptaInitiala,
      expl: ""
    }];
    indexCurent = 0;

    document.getElementById("stanga").value = stangaInitiala;
    document.getElementById("dreapta").value = dreaptaInitiala;
    document.getElementById("explicatie").value = "";

    afiseazaPasi();
  }

  function salveazaPas() {
    if (pasi.length === 0) return;

    const leftCurent = document.getElementById("stanga").value.trim();
    const rightCurent = document.getElementById("dreapta").value.trim();
    const explAnterior = document.getElementById("explicatie").value.trim();

    const pasAnterior = pasi[indexCurent];

    const check = verificaPas(pasAnterior.left, pasAnterior.right, leftCurent, rightCurent);
    if (!check.ok) {
      alert(check.msg);
      return; // NU înregistrăm pasul dacă este greșit
    }

    if (explAnterior !== "") {
      pasi[indexCurent].expl = explAnterior;
    }

    pasi.push({
      left: leftCurent,
      right: rightCurent,
      expl: ""
    });
    indexCurent = pasi.length - 1;

    document.getElementById("explicatie").value = "";
    afiseazaPasi();
  }

  function resetLaInitiala() {
    if (!stangaInitiala && !dreaptaInitiala) return;

    pasi = [{
      left: stangaInitiala,
      right: dreaptaInitiala,
      expl: ""
    }];
    indexCurent = 0;

    document.getElementById("stanga").value = stangaInitiala;
    document.getElementById("dreapta").value = dreaptaInitiala;
    document.getElementById("explicatie").value = "";

    afiseazaPasi();
  }

  // ================= TASTATURA VIRTUALĂ =================

  let activeFieldId = "stanga";

  function setActive(id) {
    activeFieldId = id;
  }

  function insertChar(ch) {
    const el = document.getElementById(activeFieldId);
    if (!el) return;
    const start = el.selectionStart ?? el.value.length;
    const end   = el.selectionEnd ?? el.value.length;
    const before = el.value.slice(0, start);
    const after  = el.value.slice(end);
    el.value = before + ch + after;
    const pos = start + ch.length;
    el.selectionStart = el.selectionEnd = pos;
    el.focus();
  }

  function insertPair(open, close) {
    const el = document.getElementById(activeFieldId);
    if (!el) return;
    const start = el.selectionStart ?? el.value.length;
    const end   = el.selectionEnd ?? el.value.length;
    const before = el.value.slice(0, start);
    const inside = el.value.slice(start, end);
    const after  = el.value.slice(end);
    const newText = before + open + inside + close + after;
    el.value = newText;
    const pos = inside ? start + open.length + inside.length
                       : start + open.length;
    el.selectionStart = el.selectionEnd = pos;
    el.focus();
  }

  function backspace() {
    const el = document.getElementById(activeFieldId);
    if (!el) return;
    const start = el.selectionStart ?? el.value.length;
    const end   = el.selectionEnd ?? el.value.length;
    if (start === 0 && end === 0) return;
    if (start === end) {
      const before = el.value.slice(0, start - 1);
      const after  = el.value.slice(end);
      el.value = before + after;
      const pos = start - 1;
      el.selectionStart = el.selectionEnd = pos;
    } else {
      const before = el.value.slice(0, start);
      const after  = el.value.slice(end);
      el.value = before + after;
      el.selectionStart = el.selectionEnd = start;
    }
    el.focus();
  }

  // pornește automat cu relația din input
  porneste();
</script>

</body>
</html>
